package com.gwt2go.dev.linker;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.SortedSet;
import java.util.UUID;

import javax.annotation.Nonnull;

import org.apache.commons.io.IOUtils;

import com.google.gwt.core.ext.LinkerContext;
import com.google.gwt.core.ext.TreeLogger;
import com.google.gwt.core.ext.UnableToCompleteException;
import com.google.gwt.core.ext.linker.AbstractLinker;
import com.google.gwt.core.ext.linker.Artifact;
import com.google.gwt.core.ext.linker.ArtifactSet;
import com.google.gwt.core.ext.linker.ConfigurationProperty;
import com.google.gwt.core.ext.linker.EmittedArtifact;
import com.google.gwt.core.ext.linker.LinkerOrder;
import com.google.gwt.core.ext.linker.impl.SelectionInformation;

/**
 * Manifest linker class creating application manifest for HTML5 offline web
 * applications supporting browsers, based on code from
 * com.google.gwt.core.linker.SimpleAppCacheLinker <br>
 *
 * @see <a href=
 *      "http://code.google.com/p/google-web-toolkit/source/browse/trunk/dev/core/src/com/google/gwt/core/linker/SimpleAppCacheLinker.java?r=10181">
 *      SimpleAppCacheLinker</a>
 *
 *      <br>
 *      ManifestLinker - linker for public path resources in the Application
 *      Cache.
 *      <p>
 *      To use:
 *      <ol>
 *      <li>Add {@code manifest="YOURMODULENAME/appcache.manifest"} to the
 *      {@code <html>} tag in your base html file. E.g.,
 *      {@code <html manifest="mymodule/appcache.manifest">}</li>
 *      <li>Add a mime-mapping to your web.xml file:
 *      <p>
 *
 *      <pre>
 * {@code <mime-mapping>
 * <extension>manifest</extension>
 * <mime-type>text/cache-manifest</mime-type>
 * </mime-mapping>
 * }
 *      </pre>
 *
 *      </li>
 *      </ol>
 *      <p>
 *      On every compile, this linker will regenerate the appcache.manifest file
 *      with files from the public path of your module.
 *      <p>
 *      To obtain a manifest that contains other files in addition to those
 *      generated by this linker, create a class that inherits from this one and
 *      overrides {@code otherCachedFiles()}, and use it as a linker instead:
 *      <p>
 *
 *      <pre>
 * <blockquote>
 * {@code @Shardable}
 * public class MyAppCacheLinker extends ManifestLinker {
 *   {@code @Override}
 *   protected String[] otherCachedFiles() {
 *     return new String[] {"/MyApp.html","/MyApp.css"};
 *   }
 *
 *   {@code @Override}
 *   protected String[] appCacheManifestTemplate() {
 *     return "myappcache.manifest";
 *   }
 * }
 * </blockquote>
 *      </pre>
 *
 * @author L.Pelov
 */
@LinkerOrder(LinkerOrder.Order.POST)
public class ManifestLinker extends AbstractLinker {

    private static final String MANIFEST = "appcache.manifest"; //$NON-NLS-1$
    private static final String MANIFESTTEMPLATE = "cache.manifest.template"; //$NON-NLS-1$
    private static final String CONFIG_PROPERTY = "cache.manifest"; //$NON-NLS-1$
    private static final String DESCRIPTION = "Application manifest linker"; //$NON-NLS-1$

    @Override
    public String getDescription() {
        return DESCRIPTION;
    }

    @Override
    public ArtifactSet link(final TreeLogger logger, final LinkerContext context, ArtifactSet artifacts, final boolean onePermutation) throws UnableToCompleteException {

        final ArtifactSet toReturn = new ArtifactSet(artifacts);
        if (onePermutation) {
            return toReturn;
        }

        if (toReturn.find(SelectionInformation.class).isEmpty()) {
            final String msg = java.text.MessageFormat.format("Warning: Clobbering {0} to allow debugging. Recompile before deploying your app!", MANIFEST); //$NON-NLS-1$
            logger.log(TreeLogger.INFO, msg);
            artifacts = null;
        } else {
            // Create the general cache-manifest resource for the landing page:
            toReturn.add(emitLandingPageCacheManifest(context, logger, artifacts));
        }
        return toReturn;

    }

    /**
     * Creates the cache-manifest resource specific for the landing page.
     *
     * @param context
     *            the linker environment
     * @param logger
     *            the tree logger to record to
     * @param artifacts
     *            {@code null} to generate an empty cache manifest
     */

    @SuppressWarnings("rawtypes")
    private Artifact<?> emitLandingPageCacheManifest(final LinkerContext context, final TreeLogger logger, final ArtifactSet artifacts) throws UnableToCompleteException {
        final StringBuilder publicSourcesSb = new StringBuilder();
        final StringBuilder staticResoucesSb = new StringBuilder();

        if (artifacts != null) {
            // Iterate over all emitted artifacts, and collect all cacheable
            // artifacts
            for (final Artifact artifact : artifacts) {
                if (artifact instanceof EmittedArtifact) {
                    final EmittedArtifact ea = (EmittedArtifact) artifact;
                    final String pathName = ea.getPartialPath();
                    if (pathName.endsWith("symbolMap") //$NON-NLS-1$
                            || pathName.endsWith(".xml.gz") //$NON-NLS-1$
                            || pathName.endsWith("rpc.log") //$NON-NLS-1$
                            || pathName.endsWith("gwt.rpc") //$NON-NLS-1$
                            || pathName.endsWith("manifest.txt") //$NON-NLS-1$
                            || pathName.startsWith("rpcPolicyManifest")) { //$NON-NLS-1$
                        // skip these resources
                    } else {
                        publicSourcesSb.append(pathName);
                        publicSourcesSb.append("\n"); //$NON-NLS-1$
                    }
                }
            }

            String[] cacheExtraFiles = getPropsExtraFiles(logger, context);

            if (cacheExtraFiles.length == 0) {
                cacheExtraFiles = getCacheExtraFiles();
            }

            for (int i = 0; i < cacheExtraFiles.length; i++) {
                staticResoucesSb.append(cacheExtraFiles[i]);
                staticResoucesSb.append("\n"); //$NON-NLS-1$
            }

        }

        final String cacheManifestString = createCache(logger, context,
                publicSourcesSb, staticResoucesSb);

        // Create the manifest as a new artifact and return it:
        return emitString(logger, cacheManifestString, MANIFEST);
    }

    /**
     * Generate the application cache manifest file
     *
     * @param logger
     *            - the tree logger to record to
     * @param context
     *            - the linker environment
     * @param publicSourcesSb
     *            - contains the public resources, generated by the compilation
     * @param staticResoucesSb
     *            - contains the static resources, defined by your subclass
     * @return
     * @throws UnableToCompleteException
     */
    protected String createCache(final TreeLogger logger, final LinkerContext context, final StringBuilder publicSourcesSb, final StringBuilder staticResoucesSb) throws UnableToCompleteException {
        try {
            String manifest = IOUtils.toString(getClass().getResourceAsStream(appCacheManifestTemplate()));

            // replace the placeholder with the real data
            manifest = manifest.replace("$UNIQUEID$", UUID.randomUUID().toString()); //$NON-NLS-1$
            manifest = manifest.replace("$STATICAPPFILES$", staticResoucesSb.toString()); //$NON-NLS-1$
            manifest = manifest.replace("$GENAPPFILES$", publicSourcesSb.toString()); //$NON-NLS-1$
            final String msg = java.text.MessageFormat.format("Be sure your landing page's <html> tag declares a manifest: <html manifest=\"{0}/{1}\">", context.getModuleFunctionName(), MANIFEST); //$NON-NLS-1$
            logger.log(TreeLogger.INFO, msg);
            return manifest;
        } catch (final IOException e) {
            logger.log(TreeLogger.ERROR, "Could not read cache manifest template.", e); //$NON-NLS-1$
            throw new UnableToCompleteException();
        }
    }

    private String[] getCacheExtraFiles() {
        final String[] cacheExtraFiles = otherCachedFiles();
        return Arrays.copyOf(cacheExtraFiles, cacheExtraFiles.length);
    }

    /**
     * Obtains the extra files to include in the manifest. Ensures the returned
     * array is not null.
     */
    @SuppressWarnings("static-method")
    @Nonnull
    protected String[] otherCachedFiles() {
        return new String[0];
    }

    /**
     * Do not forget to include this file into your <html manifest="" \>
     *
     * @return
     */
    @SuppressWarnings("static-method")
    protected String appCacheManifestTemplate() {
        return MANIFESTTEMPLATE;
    }

    protected static String[] getPropsExtraFiles(final TreeLogger logger, final LinkerContext context) {
        // get the configured external properties, if any
        // try to list the configuration properties here
        // this files should be static external files
        final SortedSet<ConfigurationProperty> configurationProperties = context.getConfigurationProperties();
        if (configurationProperties.isEmpty()) {
            logger.log(TreeLogger.INFO, "Info: No external static options have been configured, configuration-property cache.manifest is empty!"); //$NON-NLS-1$
        }
        for (final ConfigurationProperty prop : configurationProperties) {
            if (prop != null && CONFIG_PROPERTY.equalsIgnoreCase(prop.getName())) {
                final List<String> props = prop.getValues();
                return props.toArray(new String[props.size()]);
            }
        }
        return new String[0];

    }
}
